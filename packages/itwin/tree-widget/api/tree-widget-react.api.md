## API Report File for "@itwin/tree-widget-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { BeEvent } from '@itwin/core-bentley';
import type { ClassGroupingNodeKey } from '@itwin/presentation-hierarchies';
import type { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import type { GroupingHierarchyNode } from '@itwin/presentation-hierarchies';
import type { HierarchyDefinition } from '@itwin/presentation-hierarchies';
import type { HierarchyNode } from '@itwin/presentation-hierarchies-react';
import { HierarchyNode as HierarchyNode_2 } from '@itwin/presentation-hierarchies';
import { HierarchySearchPath } from '@itwin/presentation-hierarchies';
import type { Id64Arg } from '@itwin/core-bentley';
import type { Id64Array } from '@itwin/core-bentley';
import type { Id64String } from '@itwin/core-bentley';
import type { ILogger } from '@itwin/presentation-shared';
import type { IModelConnection } from '@itwin/core-frontend';
import type { InstanceKey } from '@itwin/presentation-shared';
import type { InstancesNodeKey } from '@itwin/presentation-hierarchies';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import type { Localization } from '@itwin/core-common';
import { NamedExoticComponent } from 'react';
import type { NonGroupingHierarchyNode } from '@itwin/presentation-hierarchies';
import type { PropsWithChildren } from 'react';
import type { ReactElement } from 'react';
import type { ReactNode } from 'react';
import type { SelectionStorage } from '@itwin/presentation-hierarchies-react';
import { StrataKitTreeRenderer } from '@itwin/presentation-hierarchies-react';
import type { TranslationOptions } from '@itwin/core-common';
import { TreeActionBase } from '@itwin/presentation-hierarchies-react';
import { TreeActionBaseAttributes } from '@itwin/presentation-hierarchies-react';
import type { TreeNode } from '@itwin/presentation-hierarchies-react';
import { TreeNodeFilterAction } from '@itwin/presentation-hierarchies-react';
import { TreeNodeRenameAction } from '@itwin/presentation-hierarchies-react';
import type { TreeRendererProps } from '@itwin/presentation-hierarchies-react';
import type { useIModelTree } from '@itwin/presentation-hierarchies-react';
import type { useTree } from '@itwin/presentation-hierarchies-react';
import type { Viewport } from '@itwin/core-frontend';
import type { Widget } from '@itwin/appui-react';

// @beta (undocumented)
export type BaseTreeRendererProps = React.ComponentPropsWithoutRef<typeof StrataKitTreeRenderer>;

// @beta
interface BaseTreeVisibilityHandlerOverrides {
    // (undocumented)
    changeCategoriesVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        categoryIds: Id64Arg;
        modelId?: Id64String;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeElementsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        elementIds: Id64Arg;
        modelId: Id64String;
        categoryId: Id64String;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeModelsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        modelIds: Id64Arg;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    getCategoriesVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        categoryIds: Id64Arg;
        modelId?: Id64String;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getElementsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        elementIds: Id64Arg;
        modelId: Id64String;
        categoryId: Id64String;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getModelsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        modelIds: Id64Arg;
    }) => Promise<VisibilityStatus>>;
}

// @beta (undocumented)
type CallbacksWithCommonTreeRendererProps<T extends BaseTreeRendererProps, K extends keyof T> = Omit<T, K> & {
    [P in keyof Pick<T, K>]?: T[P] extends ((props: any) => any) | undefined ? (args: Parameters<NonNullable<T[P]>>[0], treeRendererProps: CommonTreeRendererProps) => ReturnType<NonNullable<T[P]>> : never;
};

// @public
export const CategoriesTreeComponent: {
    (props: CategoriesTreeComponentProps): JSX_2.Element | null;
    ShowAllButton: CategoriesTreeHeaderButtonType;
    HideAllButton: CategoriesTreeHeaderButtonType;
    InvertAllButton: CategoriesTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface CategoriesTreeComponentProps extends Pick<CategoriesTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "searchText" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "hierarchyConfig" | "treeLabel"> {
    headerButtons?: Array<(props: CategoriesTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @public
interface CategoriesTreeHeaderButtonProps extends TreeToolbarButtonProps {
    categories: CategoryInfo[];
    models: Id64Array;
}

// @public (undocumented)
type CategoriesTreeHeaderButtonType = (props: CategoriesTreeHeaderButtonProps) => React.ReactElement | null;

// @beta
interface CategoriesTreeHierarchyConfiguration {
    hideSubCategories: boolean;
    showElements: boolean;
    showEmptyCategories: boolean;
}

// @beta (undocumented)
export function CategoriesTreeIcon({ node }: {
    node: TreeNode;
}): JSX_2.Element | undefined;

// @beta
export namespace CategoriesTreeNode {
    const isDefinitionContainerNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isCategoryNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            description?: string;
            hasSubCategories?: boolean;
        } & ({
            isCategoryOfSubModel?: false;
        } | {
            modelIds: Id64Array;
            isCategoryOfSubModel: true;
        });
    };
    const isModelNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isElementNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            modelId: Id64String;
            categoryId: Id64String;
        };
    };
    const isElementClassGroupingNode: (node: Pick<HierarchyNode_2, "key">) => node is Omit<GroupingHierarchyNode, "extendedData"> & {
        key: ClassGroupingNodeKey;
    } & {
        extendedData: {
            categoryId: Id64String;
            modelElementsMap: Map<Id64String, {
                elementIds: Set<Id64String>;
            }>;
        };
    };
    const isSubCategoryNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            categoryId: Id64String;
        };
    };
}

// @beta (undocumented)
type CategoriesTreeProps = Pick<ExtendedVisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> & Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & UseCategoriesTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
interface CategoryInfo {
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    subCategoryIds?: Id64Array;
}

// @beta (undocumented)
type ClassGroupingHierarchyNode = GroupingHierarchyNode & {
    key: ClassGroupingNodeKey;
};

// @alpha
export const ClassificationsTreeComponent: {
    (props: ClassificationsTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
    isSupportedByIModel(imodel: IModelConnection): Promise<boolean>;
};

// @alpha (undocumented)
interface ClassificationsTreeComponentProps extends Pick<ClassificationsTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "searchText" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "hierarchyConfig" | "getEditingProps" | "treeLabel"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @alpha (undocumented)
interface ClassificationsTreeHierarchyConfiguration {
    rootClassificationSystemCode: string;
}

// @beta (undocumented)
export function ClassificationsTreeIcon({ node }: {
    node: TreeNode;
}): JSX_2.Element | undefined;

// @beta
export namespace ClassificationsTreeNode {
    const isClassificationTableNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isClassificationNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isGeometricElementNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            modelId: Id64String;
            categoryId: Id64String;
        };
    };
}

// @alpha (undocumented)
type ClassificationsTreeProps = Pick<ExtendedVisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "getEditingProps" | "treeLabel"> & Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & UseClassificationsTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta (undocumented)
type CommonTreeRendererProps = Pick<BaseTreeRendererProps, "filterHierarchyLevel" | "selectionMode" | "getTreeItemProps"> & TreeRendererProps;

// @public
export function createTreeWidget(props: TreeWidgetProps): Widget;

// @beta
export function createTreeWidgetViewport(viewport: Viewport): TreeWidgetViewport;

// @beta (undocumented)
interface ElementsGroupInfo {
    // (undocumented)
    groupingNode: ClassGroupingHierarchyNode;
    // (undocumented)
    parent: {
        ids: Id64String[];
        type: "element";
    } | {
        ids: Id64String[];
        modelIds: Id64String[];
        type: "category";
    };
}

// @beta (undocumented)
type ExtendedTreeRendererProps = CallbacksWithCommonTreeRendererProps<TreeRendererProps_2, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps">;

// @beta (undocumented)
type ExtendedVisibilityTreeRendererProps = CallbacksWithCommonTreeRendererProps<VisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps">;

// @beta
export const ExternalSourcesTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, treeLabel, ...props }: ExternalSourcesTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface ExternalSourcesTreeComponentProps extends Pick<ExternalSourcesTreeProps, "selectionStorage" | "selectionMode" | "hierarchyLevelConfig" | "selectionMode" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta (undocumented)
export function ExternalSourcesTreeIcon({ node }: {
    node: TreeNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type ExternalSourcesTreeProps = Pick<ExtendedTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> & Pick<TreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @public (undocumented)
interface FocusedInstancesContext {
    enabled: boolean;
    loadFocusedItems?: () => AsyncIterableIterator<InstanceKey | GroupingHierarchyNode>;
    toggle: () => void;
}

// @public
export function FocusedInstancesContextProvider({ selectionStorage, imodelKey, children, }: PropsWithChildren<{
    selectionStorage: SelectionStorage;
    imodelKey: string;
}>): JSX_2.Element;

// @beta (undocumented)
type FunctionProps<THook extends (props: any) => any> = Parameters<THook>[0];

// @beta
export interface HierarchyVisibilityHandler extends Disposable {
    changeVisibility(node: HierarchyNode, on: boolean): Promise<void>;
    getVisibilityStatus(node: HierarchyNode): Promise<VisibilityStatus> | VisibilityStatus;
    readonly onVisibilityChange: BeEvent<() => void>;
}

// @beta
type HierarchyVisibilityHandlerOverridableMethod<TFunc> = TFunc extends (...args: any[]) => infer TResult ? (props: HierarchyVisibilityHandlerOverridableMethodProps<TFunc>) => TResult : never;

// @beta
type HierarchyVisibilityHandlerOverridableMethodProps<TFunc> = TFunc extends (props: infer TProps) => infer TResult ? TProps & {
    readonly originalImplementation: () => TResult;
    readonly handler: HierarchyVisibilityHandler;
} : never;

// @beta
export const IModelContentTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, treeLabel, ...props }: IModelContentTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface IModelContentTreeComponentProps extends Pick<IModelContentTreeProps, "selectionStorage" | "hierarchyConfig" | "hierarchyLevelConfig" | "selectionMode" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta
interface IModelContentTreeHierarchyConfiguration {
    hideRootSubject: boolean;
}

// @beta (undocumented)
export function IModelContentTreeIcon({ node }: {
    node: TreeNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type IModelContentTreeProps = Pick<ExtendedTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> & Pick<TreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
    hierarchyConfig?: Partial<IModelContentTreeHierarchyConfiguration>;
};

// @beta (undocumented)
interface LoadedTreeItemVisibilityButtonState {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    state: "visible" | "hidden" | "partial";
}

// @public
interface ModelInfo {
    // (undocumented)
    id: string;
    // (undocumented)
    isPlanProjection?: boolean;
}

// @public
export const ModelsTreeComponent: {
    (props: ModelsTreeComponentProps): JSX_2.Element | null;
    ShowAllButton: ModelsTreeHeaderButtonType;
    HideAllButton: ModelsTreeHeaderButtonType;
    InvertButton: ModelsTreeHeaderButtonType;
    View2DButton: ModelsTreeHeaderButtonType;
    View3DButton: ModelsTreeHeaderButtonType;
    ToggleInstancesFocusButton: ModelsTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface ModelsTreeComponentProps extends Pick<ModelsTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "selectionPredicate" | "hierarchyConfig" | "visibilityHandlerOverrides" | "getSearchPaths" | "searchText" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "getSubTreePaths" | "treeLabel"> {
    headerButtons?: Array<(props: ModelsTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @public
interface ModelsTreeHeaderButtonProps extends TreeToolbarButtonProps {
    models: ModelInfo[];
}

// @public (undocumented)
type ModelsTreeHeaderButtonType = (props: ModelsTreeHeaderButtonProps) => ReactElement | null;

// @beta
interface ModelsTreeHierarchyConfiguration {
    elementClassGrouping: "enable" | "enableWithCounts" | "disable";
    elementClassSpecification: string;
    hideRootSubject: boolean;
    hierarchyLevelFiltering: "enable" | "disable";
    showEmptyModels: boolean;
}

// @beta (undocumented)
export function ModelsTreeIcon({ node }: {
    node: TreeNode;
}): JSX_2.Element | undefined;

// @beta
export namespace ModelsTreeNode {
    const isSubjectNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isModelNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is NonGroupingHierarchyNode & {
        key: InstancesNodeKey;
    };
    const isCategoryNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            modelIds: Id64String[];
        };
    };
    const isElementNode: (node: Pick<HierarchyNode_2, "extendedData">) => node is Omit<NonGroupingHierarchyNode, "extendedData"> & {
        key: InstancesNodeKey;
    } & {
        extendedData: {
            modelId: Id64String;
            categoryId: Id64String;
        };
    };
    const isElementClassGroupingNode: (node: Pick<HierarchyNode_2, "key">) => node is Omit<GroupingHierarchyNode, "extendedData"> & {
        key: ClassGroupingNodeKey;
    } & {
        extendedData: {
            modelId: Id64String;
            categoryId: Id64String;
        };
    };
    const getType: (node: HierarchyNode_2) => "subject" | "model" | "category" | "element" | "elements-class-group";
}

// @beta (undocumented)
type ModelsTreeProps = Pick<ExtendedVisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getContextMenuActions" | "getTreeItemProps" | "treeLabel"> & Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & UseModelsTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
export interface ModelsTreeVisibilityHandlerOverrides extends BaseTreeVisibilityHandlerOverrides {
    // (undocumented)
    changeElementGroupingNodeVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeSubjectsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        subjectIds: Id64Arg;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    getElementGroupingNodeVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getSubjectsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        subjectIds: Id64Arg;
    }) => Promise<VisibilityStatus>>;
}

// @public (undocumented)
type NormalizedHierarchySearchPath = ReturnType<(typeof HierarchySearchPath)["normalize"]>;

// @public (undocumented)
type PerModelCategoryOverride = "show" | "hide" | "none";

// @beta
export class SearchLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @beta (undocumented)
export function SelectableTree({ buttons, children }: PropsWithChildren<TreeHeaderProps>): JSX_2.Element;

// @beta
export function SharedTreeContextProvider({ children }: PropsWithChildren<{}>): JSX_2.Element;

// @beta
export function SkeletonTree(): JSX_2.Element;

// @beta (undocumented)
export function TelemetryContextProvider({ children, onPerformanceMeasured, onFeatureUsed, componentIdentifier, }: PropsWithChildren<TelemetryContextProviderProps>): JSX_2.Element;

// @beta (undocumented)
interface TelemetryContextProviderProps {
    componentIdentifier: string;
    onFeatureUsed?: (featureId: string) => void;
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta
export function Tree({ hierarchyLevelSizeLimit, getHierarchyDefinition, getSearchPaths, selectionStorage, imodelAccess: providedIModelAccess, treeName, onReload, ...props }: TreeProps): JSX_2.Element;

export { TreeActionBase }

export { TreeActionBaseAttributes }

// @public
export interface TreeDefinition {
    getLabel: () => string;
    id: string;
    isSearchable?: boolean;
    render: (props: TreeRenderProps) => React.ReactNode;
    shouldShow?: (imodel: IModelConnection) => Promise<boolean>;
    startIcon?: React.ReactNode;
}

// @beta (undocumented)
interface TreeHeaderProps {
    // (undocumented)
    buttons?: ReactNode;
}

// @beta
type TreeItemVisibilityButtonState = (LoadedTreeItemVisibilityButtonState | {
    isLoading: true;
}) & {
    tooltip?: string;
};

export { TreeNodeFilterAction }

export { TreeNodeRenameAction }

// @beta (undocumented)
type TreeProps = Pick<FunctionProps<typeof useIModelTree>, "getSearchPaths" | "getHierarchyDefinition"> & Pick<BaseTreeRendererProps, "selectionMode"> & {
    imodel: IModelConnection;
    treeName: string;
    selectionStorage: SelectionStorage;
    selectionPredicate?: (node: TreeNode) => boolean;
    treeRenderer: (treeProps: Required<CommonTreeRendererProps & Pick<BaseTreeRendererProps, "getTreeItemProps">>) => ReactNode;
    imodelAccess?: FunctionProps<typeof useIModelTree>["imodelAccess"];
    hierarchyLevelSizeLimit?: number;
    emptyTreeContent?: ReactNode;
    onReload?: () => void;
    highlightText?: string;
};

// @beta
export function TreeRenderer(props: TreeRendererProps_2): JSX_2.Element;

// @beta (undocumented)
type TreeRendererProps_2 = BaseTreeRendererProps;

// @public
interface TreeRenderProps {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, elapsedTime: number) => void;
    // (undocumented)
    searchText?: string;
    // (undocumented)
    treeLabel: string;
}

// @public (undocumented)
interface TreeToolbarButtonProps {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    viewport: TreeWidgetViewport;
}

// @public
export class TreeWidget {
    static get i18n(): Localization;
    static get i18nNamespace(): string;
    static initialize(i18n?: Localization, logger?: ILogger): Promise<void>;
    static get logger(): ILogger;
    static terminate(): void;
    static translate(key: string, options?: TranslationOptions): string;
}

// @public
export function TreeWidgetComponent(props: TreeWidgetProps): JSX_2.Element;

// @public
interface TreeWidgetProps {
    onFeatureUsed?: (feature: string) => void;
    onPerformanceMeasured?: (feature: string, elapsedTime: number) => void;
    trees: TreeDefinition[];
}

// @public
export interface TreeWidgetViewport {
    alwaysDrawn: ReadonlySet<Id64String> | undefined;
    changeCategoryDisplay: (props: {
        categoryIds: Id64Arg;
        display: boolean;
        enableAllSubCategories?: boolean;
    }) => void;
    changeModelDisplay: (props: {
        modelIds: Id64Arg;
        display: boolean;
    }) => void;
    changeSubCategoryDisplay: (props: {
        subCategoryId: Id64String;
        display: boolean;
    }) => void;
    clearAlwaysDrawn: () => void;
    clearNeverDrawn: () => void;
    clearPerModelCategoryOverrides: (props?: {
        modelIds?: Id64Arg;
    }) => void;
    getPerModelCategoryOverride: (props: {
        modelId: Id64String;
        categoryId: Id64String;
    }) => PerModelCategoryOverride;
    iModel: IModelConnection;
    readonly isAlwaysDrawnExclusive: boolean;
    neverDrawn: ReadonlySet<Id64String> | undefined;
    onAlwaysDrawnChanged: BeEvent<() => void>;
    onDisplayedCategoriesChanged: BeEvent<() => void>;
    onDisplayedModelsChanged: BeEvent<() => void>;
    onDisplayStyleChanged: BeEvent<() => void>;
    onNeverDrawnChanged: BeEvent<() => void>;
    onPerModelCategoriesOverridesChanged: BeEvent<() => void>;
    perModelCategoryOverrides: Readonly<Iterable<{
        modelId: Id64String;
        categoryId: Id64String;
        visible: boolean;
    }>>;
    setAlwaysDrawn: (props: {
        elementIds: Set<Id64String>;
        exclusive?: boolean;
    }) => void;
    setNeverDrawn: (props: {
        elementIds: Set<Id64String>;
    }) => void;
    setPerModelCategoryOverride: (props: {
        modelIds: Id64Arg;
        categoryIds: Id64Arg;
        override: PerModelCategoryOverride;
    }) => void;
    viewsCategory: (categoryId: Id64String) => boolean;
    viewsModel: (modelId: Id64String) => boolean;
    viewsSubCategory: (subCategoryId: Id64String) => boolean;
    viewType: "2d" | "3d" | "other";
}

// @beta
export function useCategoriesTree({ searchText, activeView, onCategoriesFiltered, emptyTreeContent, hierarchyConfig, getTreeItemProps, }: UseCategoriesTreeProps): UseCategoriesTreeResult;

// @public
export function useCategoriesTreeButtonProps({ viewport }: {
    viewport: TreeWidgetViewport;
}): {
    buttonProps: Pick<CategoriesTreeHeaderButtonProps, "categories" | "viewport" | "models">;
    onCategoriesFiltered: (props: {
        categories: CategoryInfo[] | undefined;
        models?: Id64Array;
    }) => void;
};

// @beta (undocumented)
interface UseCategoriesTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    // (undocumented)
    getTreeItemProps?: ExtendedVisibilityTreeRendererProps["getTreeItemProps"];
    // (undocumented)
    hierarchyConfig?: Partial<CategoriesTreeHierarchyConfiguration>;
    // (undocumented)
    onCategoriesFiltered?: (props: {
        categories: CategoryInfo[] | undefined;
        models?: Id64Array;
    }) => void;
    // (undocumented)
    searchText?: string;
}

// @beta (undocumented)
interface UseCategoriesTreeResult {
    // (undocumented)
    getTreeItemProps: Required<ExtendedVisibilityTreeRendererProps>["getTreeItemProps"];
    // (undocumented)
    treeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getSearchPaths" | "visibilityHandlerFactory" | "highlightText" | "emptyTreeContent">;
}

// @alpha
export function useClassificationsTree({ activeView, emptyTreeContent, searchText, getTreeItemProps, ...rest }: UseClassificationsTreeProps): UseClassificationsTreeResult;

// @alpha (undocumented)
export function useClassificationsTreeDefinition(props: UseClassificationsTreeDefinitionProps): UseClassificationsTreeDefinitionResult;

// @alpha (undocumented)
interface UseClassificationsTreeDefinitionProps {
    // (undocumented)
    hierarchyConfig: ClassificationsTreeHierarchyConfiguration;
    imodels: Array<{
        imodelAccess: FunctionProps<typeof useIModelTree>["imodelAccess"];
    }>;
    search?: {
        searchText: string;
    } | {
        targetItems: Array<InstanceKey>;
    };
}

// @alpha (undocumented)
interface UseClassificationsTreeDefinitionResult {
    // (undocumented)
    definition: HierarchyDefinition;
    // (undocumented)
    getSearchPaths?: FunctionProps<typeof useTree>["getSearchPaths"];
}

// @alpha (undocumented)
interface UseClassificationsTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    // (undocumented)
    getTreeItemProps?: ExtendedVisibilityTreeRendererProps["getTreeItemProps"];
    // (undocumented)
    hierarchyConfig: ClassificationsTreeHierarchyConfiguration;
    // (undocumented)
    searchText?: string;
}

// @alpha (undocumented)
interface UseClassificationsTreeResult {
    // (undocumented)
    getTreeItemProps: Required<ExtendedVisibilityTreeRendererProps>["getTreeItemProps"];
    // (undocumented)
    treeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "visibilityHandlerFactory" | "getSearchPaths" | "emptyTreeContent" | "highlightText">;
}

// @public
export function useFocusedInstancesContext(): FocusedInstancesContext;

// @beta
export function useModelsTree({ activeView, searchText, hierarchyConfig, visibilityHandlerOverrides, getSearchPaths, onModelsFiltered, selectionPredicate: nodeTypeSelectionPredicate, emptyTreeContent, getSubTreePaths, getTreeItemProps, }: UseModelsTreeProps): UseModelsTreeResult;

// @public
export function useModelsTreeButtonProps({ imodel, viewport }: {
    imodel: IModelConnection;
    viewport: TreeWidgetViewport;
}): {
    buttonProps: Pick<ModelsTreeHeaderButtonProps, "models" | "viewport">;
    onModelsFiltered: (models: Id64String[] | undefined) => void;
};

// @beta (undocumented)
interface UseModelsTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    getSearchPaths?: (props: {
        createInstanceKeyPaths: (props: {
            targetItems: Array<InstanceKey | ElementsGroupInfo>;
        } | {
            label: string;
        }) => Promise<NormalizedHierarchySearchPath[]>;
        searchText?: string;
    }) => Promise<HierarchySearchPath[] | undefined>;
    getSubTreePaths?: (props: {
        createInstanceKeyPaths: (props: {
            targetItems: Array<InstanceKey | ElementsGroupInfo>;
        }) => Promise<NormalizedHierarchySearchPath[]>;
    }) => Promise<HierarchySearchPath[]>;
    // (undocumented)
    getTreeItemProps?: ExtendedVisibilityTreeRendererProps["getTreeItemProps"];
    // (undocumented)
    hierarchyConfig?: Partial<ModelsTreeHierarchyConfiguration>;
    // (undocumented)
    onModelsFiltered?: (modelIds: Id64String[] | undefined) => void;
    searchText?: string;
    selectionPredicate?: (props: {
        node: TreeNode;
        type: "subject" | "model" | "category" | "element" | "elements-class-group";
    }) => boolean;
    // (undocumented)
    visibilityHandlerOverrides?: ModelsTreeVisibilityHandlerOverrides;
}

// @beta (undocumented)
interface UseModelsTreeResult {
    // (undocumented)
    getTreeItemProps: Required<ExtendedVisibilityTreeRendererProps>["getTreeItemProps"];
    // (undocumented)
    treeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getSearchPaths" | "visibilityHandlerFactory" | "highlightText" | "emptyTreeContent" | "selectionPredicate">;
}

// @beta
export const VisibilityAction: NamedExoticComponent<    {
node: TreeNode;
} & TreeActionBaseAttributes>;

// @beta (undocumented)
interface VisibilityContext {
    getVisibilityButtonState: (node: TreeNode) => TreeItemVisibilityButtonState;
    onVisibilityButtonClick: (node: TreeNode, state: LoadedTreeItemVisibilityButtonState["state"]) => void;
}

// @beta
export interface VisibilityStatus {
    isDisabled?: boolean;
    state: "visible" | "partial" | "hidden";
}

// @beta
export function VisibilityTree({ visibilityHandlerFactory, treeRenderer, hierarchyLevelSizeLimit, ...props }: VisibilityTreeProps): JSX_2.Element;

// @beta (undocumented)
type VisibilityTreeProps = Omit<TreeProps, "treeRenderer" | "imodelAccess"> & {
    visibilityHandlerFactory: (props: {
        imodelAccess: ECClassHierarchyInspector;
    }) => HierarchyVisibilityHandler;
    treeRenderer: (treeProps: FunctionProps<TreeProps["treeRenderer"]> & Pick<VisibilityContext, "getVisibilityButtonState" | "onVisibilityButtonClick">) => ReactNode;
};

// @beta
export function VisibilityTreeRenderer(props: VisibilityTreeRendererProps): JSX_2.Element;

// @beta (undocumented)
type VisibilityTreeRendererProps = BaseTreeRendererProps & VisibilityContext;

// (No @packageDocumentation comment for this package)

```
