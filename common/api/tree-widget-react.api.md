## API Report File for "@itwin/tree-widget-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import type { AbstractTreeNodeLoaderWithProvider } from '@itwin/components-react';
import { BeEvent } from '@itwin/core-bentley';
import type { DelayLoadedTreeNodeItem } from '@itwin/components-react';
import type { ECClassGroupingNodeKey } from '@itwin/presentation-common';
import { HighlightableTreeProps } from '@itwin/components-react';
import type { Id64String } from '@itwin/core-bentley';
import type { IDisposable } from '@itwin/core-bentley';
import type { IFilteredPresentationTreeDataProvider } from '@itwin/presentation-components';
import type { IModelConnection } from '@itwin/core-frontend';
import type { IPresentationTreeDataProvider } from '@itwin/presentation-components';
import type { Localization } from '@itwin/core-common';
import type { LocalizationOptions } from '@itwin/core-i18n';
import type { Node as Node_2 } from '@itwin/presentation-common';
import type { NodeCheckboxRenderProps } from '@itwin/core-react';
import { NodeKey } from '@itwin/presentation-common';
import { Ref } from 'react';
import type { Ruleset } from '@itwin/presentation-common';
import type { SelectionMode as SelectionMode_2 } from '@itwin/components-react';
import type { SingleSchemaClassSpecification } from '@itwin/presentation-common';
import { StagePanelLocation } from '@itwin/appui-react';
import { StagePanelSection } from '@itwin/appui-react';
import { Subscription } from '@itwin/components-react';
import type { TreeCheckboxStateChangeEventArgs } from '@itwin/components-react';
import type { TreeNodeItem } from '@itwin/components-react';
import type { TreeNodeRendererProps } from '@itwin/components-react';
import type { TreeRendererProps } from '@itwin/components-react';
import type { TreeSelectionModificationEventArgs } from '@itwin/components-react';
import type { TreeSelectionReplacementEventArgs } from '@itwin/components-react';
import type { UiItemsProvider } from '@itwin/appui-react';
import { UnifiedSelectionTreeEventHandler } from '@itwin/presentation-components';
import type { UnifiedSelectionTreeEventHandlerParams } from '@itwin/presentation-components';
import type { ViewManager } from '@itwin/core-frontend';
import type { Viewport } from '@itwin/core-frontend';
import type { Widget } from '@itwin/appui-react';

// @public
export function areAllModelsVisible(models: string[], viewport: Viewport): boolean;

// @public
export interface BaseFilterableTreeProps extends BaseTreeProps {
    filterInfo?: VisibilityTreeFilterInfo;
    onFilterApplied?: (filteredDataProvider: IPresentationTreeDataProvider, matchesCount: number) => void;
}

// @public
export interface BaseTreeProps {
    height: number;
    iModel: IModelConnection;
    selectionMode?: SelectionMode_2;
    width: number;
}

// @internal (undocumented)
export class CachingElementIdsContainer {
    constructor(_generator: AsyncGenerator<Id64String>);
    // (undocumented)
    getElementIds(): AsyncGenerator<any, void, unknown>;
}

// @public
export const CategoriesTreeComponent: {
    (props: CategoriesTreeComponentProps): JSX.Element | null;
    ShowAllButton: typeof ShowAllButton;
    HideAllButton: typeof HideAllButton;
    InvertAllButton: typeof InvertAllButton;
    id: string;
    getLabel(): string;
};

// @public
export interface CategoriesTreeComponentProps extends Omit<CategoryTreeProps, "iModel" | "activeView" | "width" | "height" | "filterInfo" | "onFilterApplied" | "categories" | "categoryVisibilityHandler" | "viewManager"> {
    headerButtons?: Array<(props: CategoriesTreeHeaderButtonProps) => React.ReactNode>;
}

// @public
export interface CategoriesTreeHeaderButtonProps extends TreeHeaderButtonProps {
    categories: CategoryInfo[];
    filteredCategories?: CategoryInfo[];
}

// @public
export interface CategoryInfo {
    // (undocumented)
    categoryId: string;
    // (undocumented)
    subCategoryIds?: string[];
}

// @public
export function CategoryTree(props: CategoryTreeProps): JSX.Element;

// @public
export interface CategoryTreeProps extends BaseFilterableTreeProps {
    activeView: Viewport;
    allViewports?: boolean;
    categories: CategoryInfo[];
    // @internal
    categoryVisibilityHandler?: CategoryVisibilityHandler;
    // @internal
    viewManager?: ViewManager;
}

// @public
export class CategoryVisibilityHandler implements IVisibilityHandler {
    constructor(params: CategoryVisibilityHandlerParams);
    // (undocumented)
    changeVisibility(node: TreeNodeItem, shouldDisplay: boolean): Promise<void>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    enableCategory(ids: string[], enabled: boolean, enableAllSubCategories?: boolean): Promise<void>;
    // (undocumented)
    enableSubCategory(key: string, enabled: boolean): void;
    // (undocumented)
    getCategoryVisibility(id: string): "visible" | "hidden";
    // (undocumented)
    static getInstanceIdFromTreeNodeKey(nodeKey: NodeKey): string;
    // (undocumented)
    getParent(key: string): CategoryInfo | undefined;
    // (undocumented)
    getSubCategoryVisibility(id: string): "visible" | "hidden";
    // (undocumented)
    getVisibilityStatus(node: TreeNodeItem): VisibilityStatus;
    // (undocumented)
    onVisibilityChange: BeEvent<VisibilityChangeListener>;
}

// @public
export interface CategoryVisibilityHandlerParams {
    // (undocumented)
    activeView: Viewport;
    // (undocumented)
    allViewports?: boolean;
    // (undocumented)
    categories: CategoryInfo[];
    // (undocumented)
    imodel: IModelConnection;
    // (undocumented)
    viewManager: ViewManager;
}

// @public
export enum ClassGroupingOption {
    No = 0,
    Yes = 1,
    YesWithCounts = 2
}

// @internal (undocumented)
export function createRuleset(props: CreateRulesetProps): Ruleset;

// @internal (undocumented)
export type CreateRulesetProps = Omit<ModelsTreeHierarchyConfiguration, "enableElementsClassGrouping"> & {
    enableElementsClassGrouping?: boolean;
};

// @internal (undocumented)
export function createSearchRuleset(props: CreateSearchRulesetProps): Ruleset;

// @internal (undocumented)
export type CreateSearchRulesetProps = Omit<ModelsTreeHierarchyConfiguration, "enableElementsClassGrouping">;

// @public
export function createVisibilityTreeNodeRenderer({ levelOffset, disableRootNodeCollapse, descriptionEnabled, iconsEnabled }: VisibilityTreeNodeRendererProps): (treeNodeProps: TreeNodeRendererProps) => JSX.Element;

// @public
export function createVisibilityTreeRenderer({ nodeRendererProps }: VisibilityTreeRendererProps): (props: TreeRendererProps) => JSX.Element;

// @internal (undocumented)
export function customizeModelsTreeNodeItem(item: Partial<DelayLoadedTreeNodeItem>, node: Partial<Node_2>): void;

// @alpha
export function ExternalSourcesTree(props: ExternalSourcesTreeProps): JSX.Element;

// @alpha
export const ExternalSourcesTreeComponent: {
    (props: {}): JSX.Element | null;
    id: string;
    getLabel(): string;
};

// @alpha
export type ExternalSourcesTreeProps = BaseTreeProps;

// @public
export function hideAllCategories(categories: string[], viewport: Viewport): Promise<void>;

// @public
export function hideAllModels(models: string[], viewport: Viewport): Promise<void>;

// @public
export const IModelContentTree: (props: IModelContentTreeProps) => JSX.Element;

// @public
export const IModelContentTreeComponent: {
    (props: IModelContentTreeComponentProps): JSX.Element | null;
    id: string;
    getLabel(): string;
};

// @public
export type IModelContentTreeComponentProps = Omit<IModelContentTreeProps, "iModel" | "width" | "height">;

// @public
export type IModelContentTreeProps = BaseTreeProps;

// @public
export function invertAllCategories(categories: CategoryInfo[], viewport: Viewport): Promise<void>;

// @public
export function invertAllModels(models: string[], viewport: Viewport): Promise<void>;

// @public
export interface IVisibilityHandler extends IDisposable {
    // (undocumented)
    changeVisibility(node: TreeNodeItem, shouldDisplay: boolean): Promise<void>;
    // (undocumented)
    getVisibilityStatus(node: TreeNodeItem): VisibilityStatus | Promise<VisibilityStatus>;
    // (undocumented)
    onVisibilityChange: BeEvent<VisibilityChangeListener>;
}

// @public
export interface ModelInfo {
    // (undocumented)
    id: string;
    // (undocumented)
    isPlanProjection?: boolean;
}

// @public
export function ModelsTree(props: ModelsTreeProps): JSX.Element;

// @public
export const ModelsTreeComponent: {
    (props: ModelTreeComponentProps): JSX.Element | null;
    ShowAllButton: typeof ShowAllButton_2;
    HideAllButton: typeof HideAllButton_2;
    InvertButton: typeof InvertButton;
    View2DButton: typeof View2DButton;
    View3DButton: typeof View3DButton;
    id: string;
    getLabel(): string;
};

// @public
export interface ModelsTreeHeaderButtonProps extends TreeHeaderButtonProps {
    models: ModelInfo[];
}

// @public
export interface ModelsTreeHierarchyConfiguration {
    elementClassSpecification?: SingleSchemaClassSpecification;
    enableElementsClassGrouping?: ClassGroupingOption;
}

// @public
export enum ModelsTreeNodeType {
    // (undocumented)
    Category = 3,
    // (undocumented)
    Element = 4,
    // (undocumented)
    Grouping = 5,
    // (undocumented)
    Model = 2,
    // (undocumented)
    Subject = 1,
    // (undocumented)
    Unknown = 0
}

// @public
export interface ModelsTreeProps extends BaseFilterableTreeProps {
    activeView: Viewport;
    // @alpha
    enableHierarchyAutoUpdate?: boolean;
    hierarchyConfig?: ModelsTreeHierarchyConfiguration;
    modelsVisibilityHandler?: ModelsVisibilityHandler;
    selectionPredicate?: ModelsTreeSelectionPredicate;
}

// @public
export type ModelsTreeSelectionPredicate = (key: NodeKey, type: ModelsTreeNodeType) => boolean;

// @public
export class ModelsVisibilityHandler implements IVisibilityHandler {
    constructor(props: ModelsVisibilityHandlerProps);
    // (undocumented)
    protected changeCategoryState(categoryId: Id64String, parentModelId: Id64String | undefined, on: boolean): void;
    // (undocumented)
    protected changeElementGroupingNodeState(key: ECClassGroupingNodeKey, on: boolean): Promise<void>;
    // (undocumented)
    protected changeElementsState(modelId: Id64String | undefined, categoryId: Id64String | undefined, elementIds: AsyncGenerator<Id64String>, on: boolean): Promise<void>;
    // (undocumented)
    protected changeElementState(id: Id64String, modelId: Id64String | undefined, categoryId: Id64String | undefined, on: boolean): Promise<void>;
    // (undocumented)
    protected changeModelState(id: Id64String, on: boolean): Promise<void>;
    // (undocumented)
    protected changeModelsVisibility(ids: Id64String[], visible: boolean): Promise<void>;
    // (undocumented)
    protected changeSubjectNodeState(ids: Id64String[], node: TreeNodeItem, on: boolean): Promise<void | void[]>;
    changeVisibility(node: TreeNodeItem, on: boolean): Promise<void>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected getCategoryDisplayStatus(id: Id64String, parentModelId: Id64String | undefined): VisibilityStatus;
    // (undocumented)
    protected getElementDisplayStatus(elementId: Id64String, modelId: Id64String | undefined, categoryId: Id64String | undefined): VisibilityStatus;
    // (undocumented)
    protected getElementGroupingNodeDisplayStatus(_id: string, key: ECClassGroupingNodeKey): Promise<VisibilityStatus>;
    // (undocumented)
    protected getModelDisplayStatus(id: Id64String): VisibilityStatus;
    // (undocumented)
    static getNodeType(item: TreeNodeItem): ModelsTreeNodeType;
    // (undocumented)
    protected getSubjectNodeVisibility(ids: Id64String[], node: TreeNodeItem): Promise<VisibilityStatus>;
    getVisibilityStatus(node: TreeNodeItem): VisibilityStatus | Promise<VisibilityStatus>;
    // (undocumented)
    static isCategoryNode(node: TreeNodeItem): any;
    // (undocumented)
    static isModelNode(node: TreeNodeItem): any;
    // (undocumented)
    static isSubjectNode(node: TreeNodeItem): any;
    // (undocumented)
    onVisibilityChange: BeEvent<VisibilityChangeListener>;
    setFilteredDataProvider(provider: IFilteredPresentationTreeDataProvider | undefined): void;
}

// @public
export interface ModelsVisibilityHandlerProps {
    // (undocumented)
    hierarchyAutoUpdateEnabled?: boolean;
    // (undocumented)
    rulesetId: string;
    // @internal (undocumented)
    subjectModelIdsCache?: SubjectModelIdsCache;
    // (undocumented)
    viewport: Viewport;
}

// @public
export interface ModelTreeComponentProps extends Omit<ModelsTreeProps, "iModel" | "activeView" | "width" | "height" | "filterInfo" | "onFilterApplied"> {
    headerButtons?: Array<(props: ModelsTreeHeaderButtonProps) => React.ReactNode>;
}

// @internal
export const RULESET_CATEGORIES: Ruleset;

// @internal
export const RULESET_EXTERNAL_SOURCES: Ruleset;

// @internal
export const RULESET_IMODEL_CONTENT: Ruleset;

// @public
export function SelectableTree(props: SelectableTreeProps): JSX.Element | null;

// @public
export interface SelectableTreeProps {
    // (undocumented)
    trees: TreeDefinition[];
}

// @public
export function showAllCategories(categories: string[], viewport: Viewport): Promise<void>;

// @public
export function showAllModels(models: string[], viewport: Viewport): Promise<void>;

// @internal (undocumented)
export class SubjectModelIdsCache {
    constructor(imodel: IModelConnection);
    // (undocumented)
    getSubjectModelIds(subjectId: Id64String): Promise<Id64String[]>;
}

// @public
export function toggleModels(models: string[], enable: boolean, viewport: Viewport): Promise<void>;

// @public
export interface TreeDefinition {
    getLabel: () => string;
    id: string;
    render: () => React.ReactNode;
    shouldShow?: (imodel: IModelConnection) => Promise<boolean>;
}

// @public
export class TreeWidget {
    static get i18n(): Localization;
    static get i18nNamespace(): string;
    static initialize(i18n?: Localization): Promise<void>;
    // (undocumented)
    static get packageName(): string;
    static terminate(): void;
    static translate(key: string | string[], options?: LocalizationOptions): string;
}

// @public
export const TreeWidgetId = "tree-widget-react:trees";

// @public
export interface TreeWidgetOptions {
    defaultPanelLocation?: StagePanelLocation;
    defaultPanelSection?: StagePanelSection;
    defaultTreeWidgetPriority?: number;
    trees?: TreeDefinition[];
}

// @public
export class TreeWidgetUiItemsProvider implements UiItemsProvider {
    constructor(_treeWidgetOptions?: TreeWidgetOptions | undefined);
    // (undocumented)
    readonly id = "TreeWidgetUiItemsProvider";
    // (undocumented)
    provideWidgets(_stageId: string, stageUsage: string, location: StagePanelLocation, section?: StagePanelSection): ReadonlyArray<Widget>;
}

// @internal
export function useCategories(viewManager: ViewManager, imodel: IModelConnection, view?: Viewport): CategoryInfo[];

// @public
export function useTreeTransientState<T extends Element>(): Ref<T>;

// @public
export function useVisibilityTreeFiltering(nodeLoader: AbstractTreeNodeLoaderWithProvider<IPresentationTreeDataProvider>, filterInfo?: VisibilityTreeFilterInfo, onFilterApplied?: (filteredDataProvider: IPresentationTreeDataProvider, matchesCount: number) => void): {
    filteredNodeLoader: AbstractTreeNodeLoaderWithProvider<IPresentationTreeDataProvider>;
    isFiltering: boolean;
    nodeHighlightingProps: HighlightableTreeProps | undefined;
};

// @public
export type VisibilityChangeListener = (nodeIds?: string[], visibilityStatus?: Map<string, VisibilityStatus>) => void;

// @public
export interface VisibilityStatus {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    state: "visible" | "partial" | "hidden";
    // (undocumented)
    tooltip?: string;
}

// @public
export class VisibilityTreeEventHandler extends UnifiedSelectionTreeEventHandler {
    constructor(params: VisibilityTreeEventHandlerParams);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    onCheckboxStateChanged(event: TreeCheckboxStateChangeEventArgs): undefined;
    // (undocumented)
    onSelectionModified({ modifications }: TreeSelectionModificationEventArgs): Subscription | undefined;
    // (undocumented)
    onSelectionReplaced({ replacements }: TreeSelectionReplacementEventArgs): Subscription | undefined;
}

// @public
export interface VisibilityTreeEventHandlerParams extends UnifiedSelectionTreeEventHandlerParams {
    // (undocumented)
    selectionPredicate?: VisibilityTreeSelectionPredicate;
    // (undocumented)
    visibilityHandler: IVisibilityHandler;
}

// @public
export interface VisibilityTreeFilterInfo {
    // (undocumented)
    activeMatchIndex?: number;
    // (undocumented)
    filter: string;
}

// @public
export function VisibilityTreeNodeCheckbox(props: NodeCheckboxRenderProps): JSX.Element;

// @public
export interface VisibilityTreeNodeRendererProps {
    descriptionEnabled: boolean;
    disableRootNodeCollapse?: boolean;
    iconsEnabled: boolean;
    levelOffset?: number;
}

// @public
export function VisibilityTreeNoFilteredData(props: VisibilityTreeNoFilteredDataProps): JSX.Element;

// @public
export interface VisibilityTreeNoFilteredDataProps {
    // (undocumented)
    message: string;
    // (undocumented)
    title: string;
}

// @public
export interface VisibilityTreeRendererProps {
    nodeRendererProps: VisibilityTreeNodeRendererProps;
}

// @public
export type VisibilityTreeSelectionPredicate = (node: TreeNodeItem) => boolean;

// (No @packageDocumentation comment for this package)

```
