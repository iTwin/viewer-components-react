## API Report File for "@itwin/tree-widget-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { BeEvent } from '@itwin/core-bentley';
import type { ClassGroupingNodeKey } from '@itwin/presentation-hierarchies';
import type { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import { FilterAction } from '@itwin/presentation-hierarchies-react';
import type { GroupingHierarchyNode } from '@itwin/presentation-hierarchies';
import { HierarchyFilteringPath } from '@itwin/presentation-hierarchies';
import type { HierarchyNode } from '@itwin/presentation-hierarchies-react';
import type { Id64Arg } from '@itwin/core-bentley';
import type { Id64Array } from '@itwin/core-bentley';
import type { Id64String } from '@itwin/core-bentley';
import type { ILogger } from '@itwin/presentation-shared';
import type { IModelConnection } from '@itwin/core-frontend';
import type { InstanceKey } from '@itwin/presentation-shared';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import type { Localization } from '@itwin/core-common';
import { NamedExoticComponent } from 'react';
import type { PresentationHierarchyNode } from '@itwin/presentation-hierarchies-react';
import type { PropsWithChildren } from 'react';
import type { ReactNode } from 'react';
import { RenameAction } from '@itwin/presentation-hierarchies-react';
import type { SelectionStorage } from '@itwin/presentation-hierarchies-react';
import { StrataKitTreeRenderer } from '@itwin/presentation-hierarchies-react';
import type { TranslationOptions } from '@itwin/core-common';
import type { TreeRendererProps } from '@itwin/presentation-hierarchies-react';
import type { useIModelTree } from '@itwin/presentation-hierarchies-react';
import type { useSelectionHandler } from '@itwin/presentation-hierarchies-react';
import type { Viewport } from '@itwin/core-frontend';
import type { Widget } from '@itwin/appui-react';

// @beta (undocumented)
export type BaseTreeRendererProps = React.ComponentPropsWithoutRef<typeof StrataKitTreeRenderer>;

// @beta
interface BaseTreeVisibilityHandlerOverrides {
    // (undocumented)
    changeCategoriesVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        categoryIds: Id64Arg;
        modelId?: Id64String;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeElementsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        elementIds: Id64Arg;
        modelId: Id64String;
        categoryId: Id64String;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeModelsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        modelIds: Id64Arg;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    getCategoriesVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        categoryIds: Id64Arg;
        modelId?: Id64String;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getElementsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        elementIds: Id64Arg;
        modelId: Id64String;
        categoryId: Id64String;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getModelsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        modelIds: Id64Arg;
    }) => Promise<VisibilityStatus>>;
}

// @public
export const CategoriesTreeComponent: {
    (props: CategoriesTreeComponentProps): JSX_2.Element | null;
    ShowAllButton: CategoriesTreeHeaderButtonType;
    HideAllButton: CategoriesTreeHeaderButtonType;
    InvertAllButton: CategoriesTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface CategoriesTreeComponentProps extends Pick<CategoriesTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "filter" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getDecorations" | "hierarchyConfig"> {
    headerButtons?: Array<(props: CategoriesTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @public
interface CategoriesTreeHeaderButtonProps extends TreeToolbarButtonProps {
    categories: CategoryInfo[];
    models: Id64Array;
}

// @public (undocumented)
type CategoriesTreeHeaderButtonType = (props: CategoriesTreeHeaderButtonProps) => React.ReactElement | null;

// @beta
interface CategoriesTreeHierarchyConfiguration {
    hideSubCategories: boolean;
    showElements: boolean;
}

// @beta (undocumented)
export function CategoriesTreeIcon({ node }: {
    node: PresentationHierarchyNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type CategoriesTreeProps = Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & Pick<VisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & UseCategoriesTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
interface CategoryInfo {
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    subCategoryIds?: Id64Array;
}

// @beta (undocumented)
type ClassGroupingHierarchyNode = GroupingHierarchyNode & {
    key: ClassGroupingNodeKey;
};

// @alpha
export const ClassificationsTreeComponent: {
    (props: ClassificationsTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
    isSupportedByIModel(imodel: IModelConnection): Promise<boolean>;
};

// @alpha (undocumented)
interface ClassificationsTreeComponentProps extends Pick<ClassificationsTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "filter" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getDecorations" | "hierarchyConfig" | "getEditingProps"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @alpha (undocumented)
interface ClassificationsTreeHierarchyConfiguration {
    rootClassificationSystemCode: string;
}

// @beta (undocumented)
export function ClassificationsTreeIcon({ node }: {
    node: PresentationHierarchyNode;
}): JSX_2.Element | undefined;

// @alpha (undocumented)
type ClassificationsTreeProps = Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & Pick<VisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations" | "getEditingProps"> & UseClassificationsTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @public
export function createTreeWidget(props: TreeWidgetProps): Widget;

// @beta
export function createTreeWidgetViewport(viewport: Viewport): TreeWidgetViewport;

// @beta (undocumented)
interface ElementsGroupInfo {
    // (undocumented)
    groupingNode: ClassGroupingHierarchyNode;
    // (undocumented)
    parent: {
        ids: Id64String[];
        type: "element";
    } | {
        ids: Id64String[];
        modelIds: Id64String[];
        type: "category";
    };
}

// @beta
export const ExternalSourcesTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, ...props }: ExternalSourcesTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface ExternalSourcesTreeComponentProps extends Pick<ExternalSourcesTreeProps, "selectionStorage" | "selectionMode" | "hierarchyLevelConfig" | "selectionMode" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getDecorations"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta (undocumented)
export function ExternalSourcesTreeIcon({ node }: {
    node: PresentationHierarchyNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type ExternalSourcesTreeProps = Pick<TreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & Pick<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

export { FilterAction }

// @beta
export class FilterLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @public (undocumented)
interface FocusedInstancesContext {
    enabled: boolean;
    loadFocusedItems?: () => AsyncIterableIterator<InstanceKey | GroupingHierarchyNode>;
    toggle: () => void;
}

// @public
export function FocusedInstancesContextProvider({ selectionStorage, imodelKey, children, }: PropsWithChildren<{
    selectionStorage: SelectionStorage;
    imodelKey: string;
}>): JSX_2.Element;

// @beta (undocumented)
type FunctionProps<THook extends (props: any) => any> = Parameters<THook>[0];

// @beta
export interface HierarchyVisibilityHandler extends Disposable {
    changeVisibility(node: HierarchyNode, on: boolean): Promise<void>;
    getVisibilityStatus(node: HierarchyNode): Promise<VisibilityStatus> | VisibilityStatus;
    readonly onVisibilityChange: BeEvent<() => void>;
}

// @beta
type HierarchyVisibilityHandlerOverridableMethod<TFunc> = TFunc extends (...args: any[]) => infer TResult ? (props: HierarchyVisibilityHandlerOverridableMethodProps<TFunc>) => TResult : never;

// @beta
type HierarchyVisibilityHandlerOverridableMethodProps<TFunc> = TFunc extends (props: infer TProps) => infer TResult ? TProps & {
    readonly originalImplementation: () => TResult;
    readonly handler: HierarchyVisibilityHandler;
} : never;

// @beta
export const IModelContentTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, ...props }: IModelContentTreeComponentProps): JSX_2.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface IModelContentTreeComponentProps extends Pick<IModelContentTreeProps, "selectionStorage" | "hierarchyConfig" | "hierarchyLevelConfig" | "selectionMode" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getDecorations"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta
interface IModelContentTreeHierarchyConfiguration {
    hideRootSubject: boolean;
}

// @beta (undocumented)
export function IModelContentTreeIcon({ node }: {
    node: PresentationHierarchyNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type IModelContentTreeProps = Pick<TreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & Pick<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
    hierarchyConfig?: Partial<IModelContentTreeHierarchyConfiguration>;
};

// @beta (undocumented)
interface LoadedTreeItemVisibilityButtonState {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    state: "visible" | "hidden" | "partial";
}

// @public
interface ModelInfo {
    // (undocumented)
    id: string;
    // (undocumented)
    isPlanProjection?: boolean;
}

// @public
export const ModelsTreeComponent: {
    (props: ModelsTreeComponentProps): JSX_2.Element | null;
    ShowAllButton: ModelsTreeHeaderButtonType;
    HideAllButton: ModelsTreeHeaderButtonType;
    InvertButton: ModelsTreeHeaderButtonType;
    View2DButton: ModelsTreeHeaderButtonType;
    View3DButton: ModelsTreeHeaderButtonType;
    ToggleInstancesFocusButton: ModelsTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface ModelsTreeComponentProps extends Pick<ModelsTreeProps, "selectionStorage" | "hierarchyLevelConfig" | "selectionMode" | "selectionPredicate" | "hierarchyConfig" | "visibilityHandlerOverrides" | "getFilteredPaths" | "filter" | "emptyTreeContent" | "getInlineActions" | "getMenuActions" | "getDecorations" | "getSubTreePaths"> {
    headerButtons?: Array<(props: ModelsTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
    viewport?: TreeWidgetViewport;
}

// @public
interface ModelsTreeHeaderButtonProps extends TreeToolbarButtonProps {
    models: ModelInfo[];
}

// @public (undocumented)
type ModelsTreeHeaderButtonType = (props: ModelsTreeHeaderButtonProps) => React.ReactElement | null;

// @beta
interface ModelsTreeHierarchyConfiguration {
    elementClassGrouping: "enable" | "enableWithCounts" | "disable";
    elementClassSpecification: string;
    hideRootSubject: boolean;
    hierarchyLevelFiltering: "enable" | "disable";
    showEmptyModels: boolean;
}

// @beta (undocumented)
export function ModelsTreeIcon({ node }: {
    node: PresentationHierarchyNode;
}): JSX_2.Element | undefined;

// @beta (undocumented)
type ModelsTreeProps = Pick<VisibilityTreeProps, "imodel" | "selectionStorage" | "selectionMode" | "emptyTreeContent"> & Pick<VisibilityTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & UseModelsTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
export interface ModelsTreeVisibilityHandlerOverrides extends BaseTreeVisibilityHandlerOverrides {
    // (undocumented)
    changeElementGroupingNodeVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeSubjectsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        subjectIds: Id64Arg;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    getElementGroupingNodeVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getSubjectsVisibilityStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        subjectIds: Id64Arg;
    }) => Promise<VisibilityStatus>>;
}

// @public (undocumented)
type NormalizedHierarchyFilteringPath = ReturnType<(typeof HierarchyFilteringPath)["normalize"]>;

// @public (undocumented)
type PerModelCategoryOverride = "show" | "hide" | "none";

export { RenameAction }

// @beta (undocumented)
export function SelectableTree({ buttons, children }: PropsWithChildren<TreeHeaderProps>): JSX_2.Element;

// @beta
export function SkeletonTree(): JSX_2.Element;

// @beta (undocumented)
export function TelemetryContextProvider({ children, onPerformanceMeasured, onFeatureUsed, componentIdentifier, }: PropsWithChildren<TelemetryContextProviderProps>): JSX_2.Element;

// @beta (undocumented)
interface TelemetryContextProviderProps {
    componentIdentifier: string;
    onFeatureUsed?: (featureId: string) => void;
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta
export function Tree({ hierarchyLevelSizeLimit, getHierarchyDefinition, getFilteredPaths, selectionStorage, imodelAccess: providedIModelAccess, treeName, onReload, ...props }: TreeProps): JSX_2.Element;

// @public
export interface TreeDefinition {
    getLabel: () => string;
    id: string;
    isSearchable?: boolean;
    render: (props: TreeRenderProps) => React.ReactNode;
    shouldShow?: (imodel: IModelConnection) => Promise<boolean>;
    startIcon?: React.ReactNode;
}

// @beta (undocumented)
interface TreeHeaderProps {
    // (undocumented)
    buttons?: ReactNode;
}

// @beta (undocumented)
interface TreeItemVisibilityButtonProps {
    reserveSpace?: true;
}

// @beta
type TreeItemVisibilityButtonState = (LoadedTreeItemVisibilityButtonState | {
    isLoading: true;
}) & {
    tooltip?: string;
};

// @beta (undocumented)
type TreeProps = Pick<FunctionProps<typeof useIModelTree>, "getFilteredPaths" | "getHierarchyDefinition"> & Partial<Pick<FunctionProps<typeof useSelectionHandler>, "selectionMode">> & {
    imodel: IModelConnection;
    treeName: string;
    selectionStorage: SelectionStorage;
    selectionPredicate?: (node: PresentationHierarchyNode) => boolean;
    treeRenderer: (treeProps: Required<Pick<BaseTreeRendererProps, "getLabel" | "onFilterClick" | "selectionMode" | "getLabel"> & TreeRendererProps>) => ReactNode;
    imodelAccess?: FunctionProps<typeof useIModelTree>["imodelAccess"];
    hierarchyLevelSizeLimit?: number;
    emptyTreeContent?: ReactNode;
    onReload?: () => void;
    highlightText?: string;
};

// @beta
export function TreeRenderer(props: TreeRendererProps_2): JSX_2.Element;

// @beta (undocumented)
type TreeRendererProps_2 = Omit<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & {
    [Property in keyof Pick<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations">]?: (node: PresentationHierarchyNode, treeRendererProps: TreeRendererProps_2) => ReturnType<NonNullable<BaseTreeRendererProps[Property]>>;
};

// @public
interface TreeRenderProps {
    // (undocumented)
    filter?: string;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, elapsedTime: number) => void;
}

// @public (undocumented)
interface TreeToolbarButtonProps {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    viewport: TreeWidgetViewport;
}

// @public
export class TreeWidget {
    static get i18n(): Localization;
    static get i18nNamespace(): string;
    static initialize(i18n?: Localization, logger?: ILogger): Promise<void>;
    static get logger(): ILogger;
    static terminate(): void;
    static translate(key: string, options?: TranslationOptions): string;
}

// @public
export function TreeWidgetComponent(props: TreeWidgetProps): JSX_2.Element;

// @public
interface TreeWidgetProps {
    onFeatureUsed?: (feature: string) => void;
    onPerformanceMeasured?: (feature: string, elapsedTime: number) => void;
    trees: TreeDefinition[];
}

// @public
export interface TreeWidgetViewport {
    alwaysDrawn: ReadonlySet<Id64String> | undefined;
    changeCategoryDisplay: (props: {
        categoryIds: Id64Arg;
        display: boolean;
        enableAllSubCategories?: boolean;
    }) => void;
    changeModelDisplay: (props: {
        modelIds: Id64Arg;
        display: boolean;
    }) => void;
    changeSubCategoryDisplay: (props: {
        subCategoryId: Id64String;
        display: boolean;
    }) => void;
    clearAlwaysDrawn: () => void;
    clearNeverDrawn: () => void;
    clearPerModelCategoryOverrides: (props?: {
        modelIds?: Id64Arg;
    }) => void;
    getPerModelCategoryOverride: (props: {
        modelId: Id64String;
        categoryId: Id64String;
    }) => PerModelCategoryOverride;
    iModel: IModelConnection;
    readonly isAlwaysDrawnExclusive: boolean;
    neverDrawn: ReadonlySet<Id64String> | undefined;
    onAlwaysDrawnChanged: BeEvent<() => void>;
    onDisplayedCategoriesChanged: BeEvent<() => void>;
    onDisplayedModelsChanged: BeEvent<() => void>;
    onDisplayStyleChanged: BeEvent<() => void>;
    onNeverDrawnChanged: BeEvent<() => void>;
    onPerModelCategoriesOverridesChanged: BeEvent<() => void>;
    perModelCategoryOverrides: Readonly<Iterable<{
        modelId: Id64String;
        categoryId: Id64String;
        visible: boolean;
    }>>;
    setAlwaysDrawn: (props: {
        elementIds: Set<Id64String>;
        exclusive?: boolean;
    }) => void;
    setNeverDrawn: (props: {
        elementIds: Set<Id64String>;
    }) => void;
    setPerModelCategoryOverride: (props: {
        modelIds: Id64Arg;
        categoryIds: Id64Arg;
        override: PerModelCategoryOverride;
    }) => void;
    viewsCategory: (categoryId: Id64String) => boolean;
    viewsModel: (modelId: Id64String) => boolean;
    viewsSubCategory: (subCategoryId: Id64String) => boolean;
    viewType: "2d" | "3d" | "other";
}

// @beta
export function useCategoriesTree({ filter, activeView, onCategoriesFiltered, emptyTreeContent, hierarchyConfig, }: UseCategoriesTreeProps): UseCategoriesTreeResult;

// @public
export function useCategoriesTreeButtonProps({ viewport }: {
    viewport: TreeWidgetViewport;
}): {
    buttonProps: Pick<CategoriesTreeHeaderButtonProps, "categories" | "viewport" | "models">;
    onCategoriesFiltered: (props: {
        categories: CategoryInfo[] | undefined;
        models?: Id64Array;
    }) => void;
};

// @beta (undocumented)
interface UseCategoriesTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    // (undocumented)
    filter?: string;
    // (undocumented)
    hierarchyConfig?: Partial<CategoriesTreeHierarchyConfiguration>;
    // (undocumented)
    onCategoriesFiltered?: (props: {
        categories: CategoryInfo[] | undefined;
        models?: Id64Array;
    }) => void;
}

// @beta (undocumented)
interface UseCategoriesTreeResult {
    // (undocumented)
    categoriesTreeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getFilteredPaths" | "visibilityHandlerFactory" | "highlightText" | "emptyTreeContent">;
    // (undocumented)
    rendererProps: Required<Pick<VisibilityTreeRendererProps, "getDecorations" | "getSublabel">>;
}

// @alpha
export function useClassificationsTree({ activeView, emptyTreeContent, filter, ...rest }: UseClassificationsTreeProps): UseClassificationsTreeResult;

// @alpha (undocumented)
interface UseClassificationsTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    // (undocumented)
    filter?: string;
    // (undocumented)
    hierarchyConfig: ClassificationsTreeHierarchyConfiguration;
}

// @alpha (undocumented)
interface UseClassificationsTreeResult {
    // (undocumented)
    classificationsTreeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "visibilityHandlerFactory" | "getFilteredPaths" | "emptyTreeContent" | "highlightText">;
    // (undocumented)
    rendererProps: Required<Pick<VisibilityTreeRendererProps, "getDecorations">>;
}

// @public
export function useFocusedInstancesContext(): FocusedInstancesContext;

// @beta
export function useModelsTree({ activeView, filter, hierarchyConfig, visibilityHandlerOverrides, getFilteredPaths, onModelsFiltered, selectionPredicate: nodeTypeSelectionPredicate, emptyTreeContent, getSubTreePaths, }: UseModelsTreeProps): UseModelsTreeResult;

// @public
export function useModelsTreeButtonProps({ imodel, viewport }: {
    imodel: IModelConnection;
    viewport: TreeWidgetViewport;
}): {
    buttonProps: Pick<ModelsTreeHeaderButtonProps, "models" | "viewport">;
    onModelsFiltered: (models: Id64String[] | undefined) => void;
};

// @beta (undocumented)
interface UseModelsTreeProps {
    // (undocumented)
    activeView: TreeWidgetViewport;
    // (undocumented)
    emptyTreeContent?: ReactNode;
    filter?: string;
    getFilteredPaths?: (props: {
        createInstanceKeyPaths: (props: {
            targetItems: Array<InstanceKey | ElementsGroupInfo>;
        } | {
            label: string;
        }) => Promise<NormalizedHierarchyFilteringPath[]>;
        filter?: string;
    }) => Promise<HierarchyFilteringPath[] | undefined>;
    getSubTreePaths?: (props: {
        createInstanceKeyPaths: (props: {
            targetItems: Array<InstanceKey | ElementsGroupInfo>;
        }) => Promise<NormalizedHierarchyFilteringPath[]>;
    }) => Promise<HierarchyFilteringPath[]>;
    // (undocumented)
    hierarchyConfig?: Partial<ModelsTreeHierarchyConfiguration>;
    // (undocumented)
    onModelsFiltered?: (modelIds: Id64String[] | undefined) => void;
    selectionPredicate?: (props: {
        node: PresentationHierarchyNode;
        type: "subject" | "model" | "category" | "element" | "elements-class-group";
    }) => boolean;
    // (undocumented)
    visibilityHandlerOverrides?: ModelsTreeVisibilityHandlerOverrides;
}

// @beta (undocumented)
interface UseModelsTreeResult {
    // (undocumented)
    modelsTreeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getFilteredPaths" | "visibilityHandlerFactory" | "highlightText" | "emptyTreeContent" | "selectionPredicate">;
    // (undocumented)
    rendererProps: Required<Pick<VisibilityTreeRendererProps, "getDecorations">>;
}

// @beta
export const VisibilityAction: NamedExoticComponent<TreeItemVisibilityButtonProps & {
node: PresentationHierarchyNode;
}>;

// @beta (undocumented)
interface VisibilityContext {
    getVisibilityButtonState: (node: PresentationHierarchyNode) => TreeItemVisibilityButtonState;
    onVisibilityButtonClick: (node: PresentationHierarchyNode, state: LoadedTreeItemVisibilityButtonState["state"]) => void;
}

// @beta
export interface VisibilityStatus {
    isDisabled?: boolean;
    state: "visible" | "partial" | "hidden";
}

// @beta
export function VisibilityTree({ visibilityHandlerFactory, treeRenderer, hierarchyLevelSizeLimit, ...props }: VisibilityTreeProps): JSX_2.Element;

// @beta (undocumented)
type VisibilityTreeProps = Omit<TreeProps, "treeRenderer" | "imodelAccess"> & {
    visibilityHandlerFactory: (props: {
        imodelAccess: ECClassHierarchyInspector;
    }) => HierarchyVisibilityHandler;
    treeRenderer: (treeProps: FunctionProps<TreeProps["treeRenderer"]> & Pick<VisibilityContext, "getVisibilityButtonState" | "onVisibilityButtonClick">) => ReactNode;
};

// @beta
export function VisibilityTreeRenderer(props: VisibilityTreeRendererProps): JSX_2.Element;

// @beta (undocumented)
type VisibilityTreeRendererProps = Omit<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations"> & {
    [Property in keyof Pick<BaseTreeRendererProps, "getInlineActions" | "getMenuActions" | "getDecorations">]?: (node: PresentationHierarchyNode, treeRendererProps: VisibilityTreeRendererProps) => ReturnType<NonNullable<BaseTreeRendererProps[Property]>>;
} & VisibilityContext;

// (No @packageDocumentation comment for this package)

```
