## API Report File for "@itwin/tree-widget-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import type { BeEvent } from '@itwin/core-bentley';
import type { ClassGroupingNodeKey } from '@itwin/presentation-hierarchies';
import type { ComponentPropsWithoutRef } from 'react';
import type { ECClassHierarchyInspector } from '@itwin/presentation-shared';
import type { GroupingHierarchyNode } from '@itwin/presentation-hierarchies';
import type { HierarchyFilteringPath } from '@itwin/presentation-hierarchies';
import type { HierarchyNode } from '@itwin/presentation-hierarchies-react';
import type { Id64Arg } from '@itwin/core-bentley';
import type { Id64Array } from '@itwin/core-bentley';
import type { Id64Set } from '@itwin/core-bentley';
import type { Id64String } from '@itwin/core-bentley';
import type { IDisposable } from '@itwin/core-bentley';
import type { IModelConnection } from '@itwin/core-frontend';
import type { InstanceKey } from '@itwin/presentation-shared';
import type { Localization } from '@itwin/core-common';
import type { PresentationHierarchyNode } from '@itwin/presentation-hierarchies-react';
import type { PresentationTreeNode } from '@itwin/presentation-hierarchies-react';
import type { PropsWithChildren } from 'react';
import type { ReactNode } from 'react';
import type { RenderedTreeNode } from '@itwin/presentation-hierarchies-react';
import type { SchemaContext } from '@itwin/ecschema-metadata';
import type { SelectionStorage } from '@itwin/presentation-hierarchies-react';
import type { TranslationOptions } from '@itwin/core-common';
import { Tree as Tree_2 } from '@itwin/itwinui-react';
import { TreeNodeRenderer } from '@itwin/presentation-hierarchies-react';
import type { useIModelTree } from '@itwin/presentation-hierarchies-react';
import { useSelectionHandler } from '@itwin/presentation-hierarchies-react';
import type { Viewport } from '@itwin/core-frontend';
import type { Widget } from '@itwin/appui-react';

// @public
export const CategoriesTreeComponent: {
    (props: CategoriesTreeComponentProps): JSX.Element | null;
    ShowAllButton: CategoriesTreeHeaderButtonType;
    HideAllButton: CategoriesTreeHeaderButtonType;
    InvertAllButton: CategoriesTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface CategoriesTreeComponentProps extends Pick<CategoriesTreeProps, "getSchemaContext" | "selectionStorage" | "density" | "hierarchyLevelConfig" | "selectionMode"> {
    headerButtons?: Array<(props: CategoriesTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @public
interface CategoriesTreeHeaderButtonProps extends TreeHeaderButtonProps {
    categories: CategoryInfo[];
}

// @public (undocumented)
type CategoriesTreeHeaderButtonType = (props: CategoriesTreeHeaderButtonProps) => JSX.Element | null;

// @beta (undocumented)
type CategoriesTreeProps = Pick<VisibilityTreeProps, "imodel" | "getSchemaContext" | "selectionStorage" | "density" | "selectionMode"> & UseCategoriesTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
interface CategoryInfo {
    // (undocumented)
    categoryId: string;
    // (undocumented)
    subCategoryIds?: string[];
}

// @beta (undocumented)
interface ChangeCategoryVisibilityStateProps extends GetCategoryVisibilityStatusProps {
    // (undocumented)
    on: boolean;
}

// @beta (undocumented)
interface ChangeGeometricElementsDisplayStateProps {
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    elementIds: Id64Set;
    // (undocumented)
    modelId: Id64String;
    // (undocumented)
    on: boolean;
}

// @beta (undocumented)
interface ChangeModelVisibilityStateProps {
    // (undocumented)
    ids: Id64Arg;
    // (undocumented)
    on: boolean;
}

// @beta (undocumented)
type ClassGroupingHierarchyNode = GroupingHierarchyNode & {
    key: ClassGroupingNodeKey;
};

// @public
export function createTreeWidget(props: TreeWidgetProps): Widget;

// @beta (undocumented)
interface ElementsGroupInfo {
    // (undocumented)
    groupingNode: ClassGroupingHierarchyNode;
    // (undocumented)
    parent: {
        ids: Id64String[];
        type: "element";
    } | {
        ids: Id64String[];
        modelIds: Id64String[];
        type: "category";
    };
}

// @beta
export const ExternalSourcesTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, ...props }: ExternalSourcesTreeComponentProps): JSX.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface ExternalSourcesTreeComponentProps extends Pick<ExternalSourcesTreeProps, "getSchemaContext" | "selectionStorage" | "selectionMode" | "density" | "hierarchyLevelConfig" | "selectionMode"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta (undocumented)
type ExternalSourcesTreeProps = Pick<TreeProps, "imodel" | "getSchemaContext" | "selectionStorage" | "density" | "selectionMode"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
export class FilterLimitExceededError extends Error {
    constructor(limit: number);
    // (undocumented)
    readonly limit: number;
}

// @public (undocumented)
interface FocusedInstancesContext {
    enabled: boolean;
    loadFocusedItems?: () => AsyncIterableIterator<InstanceKey | GroupingHierarchyNode>;
    toggle: () => void;
}

// @public
export function FocusedInstancesContextProvider({ selectionStorage, imodelKey, children, }: PropsWithChildren<{
    selectionStorage: SelectionStorage;
    imodelKey: string;
}>): JSX.Element;

// @beta (undocumented)
type FunctionProps<THook extends (props: any) => any> = Parameters<THook>[0];

// @beta (undocumented)
interface GetCategoryVisibilityStatusProps {
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    modelId: Id64String;
}

// @beta (undocumented)
interface GetGeometricElementVisibilityStatusProps {
    // (undocumented)
    categoryId: Id64String;
    // (undocumented)
    elementId: Id64String;
    // (undocumented)
    modelId: Id64String;
}

// @beta
export interface HierarchyVisibilityHandler extends IDisposable {
    changeVisibility(node: HierarchyNode, on: boolean): Promise<void>;
    getVisibilityStatus(node: HierarchyNode): Promise<VisibilityStatus> | VisibilityStatus;
    readonly onVisibilityChange: BeEvent<() => void>;
}

// @beta
type HierarchyVisibilityHandlerOverridableMethod<TFunc> = TFunc extends (...args: any[]) => infer TResult ? (props: HierarchyVisibilityHandlerOverridableMethodProps<TFunc>) => TResult : never;

// @beta
type HierarchyVisibilityHandlerOverridableMethodProps<TFunc> = TFunc extends (props: infer TProps) => infer TResult ? TProps & {
    readonly originalImplementation: () => TResult;
    readonly handler: HierarchyVisibilityHandler;
} : never;

// @beta (undocumented)
interface HighlightInfo {
    // (undocumented)
    text: string;
}

// @beta
export const IModelContentTreeComponent: {
    ({ onFeatureUsed, onPerformanceMeasured, ...props }: IModelContentTreeComponentProps): JSX.Element | null;
    id: string;
    getLabel(): string;
};

// @beta (undocumented)
interface IModelContentTreeComponentProps extends Pick<IModelContentTreeProps, "getSchemaContext" | "selectionStorage" | "density" | "hierarchyLevelConfig" | "selectionMode"> {
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta (undocumented)
type IModelContentTreeProps = Pick<TreeProps, "imodel" | "getSchemaContext" | "selectionStorage" | "density" | "selectionMode"> & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @public
interface ModelInfo {
    // (undocumented)
    id: string;
    // (undocumented)
    isPlanProjection?: boolean;
}

// @public
export const ModelsTreeComponent: {
    (props: ModelsTreeComponentProps): JSX.Element | null;
    ShowAllButton: ModelsTreeHeaderButtonType;
    HideAllButton: ModelsTreeHeaderButtonType;
    InvertButton: ModelsTreeHeaderButtonType;
    View2DButton: ModelsTreeHeaderButtonType;
    View3DButton: ModelsTreeHeaderButtonType;
    ToggleInstancesFocusButton: ModelsTreeHeaderButtonType;
    id: string;
    getLabel(): string;
};

// @public (undocumented)
interface ModelsTreeComponentProps extends Pick<ModelsTreeProps, "getSchemaContext" | "selectionStorage" | "density" | "hierarchyLevelConfig" | "selectionMode" | "selectionPredicate" | "hierarchyConfig" | "visibilityHandlerOverrides" | "getFilteredPaths"> {
    headerButtons?: Array<(props: ModelsTreeHeaderButtonProps) => React.ReactNode>;
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @public
interface ModelsTreeHeaderButtonProps extends TreeHeaderButtonProps {
    models: ModelInfo[];
}

// @public (undocumented)
type ModelsTreeHeaderButtonType = (props: ModelsTreeHeaderButtonProps) => JSX.Element | null;

// @beta
interface ModelsTreeHierarchyConfiguration {
    elementClassGrouping: "enable" | "enableWithCounts" | "disable";
    elementClassSpecification: string;
    showEmptyModels: boolean;
}

// @beta (undocumented)
type ModelsTreeProps = Pick<VisibilityTreeProps, "imodel" | "getSchemaContext" | "selectionStorage" | "density" | "selectionMode"> & UseModelsTreeProps & {
    hierarchyLevelConfig?: {
        sizeLimit?: number;
    };
};

// @beta
export interface ModelsTreeVisibilityHandlerOverrides {
    // (undocumented)
    changeCategoryState?: HierarchyVisibilityHandlerOverridableMethod<(props: ChangeCategoryVisibilityStateProps) => Promise<void>>;
    // (undocumented)
    changeElementGroupingNodeState?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    changeElementsState?: HierarchyVisibilityHandlerOverridableMethod<(props: ChangeGeometricElementsDisplayStateProps) => Promise<void>>;
    // (undocumented)
    changeModelState?: HierarchyVisibilityHandlerOverridableMethod<(props: ChangeModelVisibilityStateProps) => Promise<void>>;
    // (undocumented)
    changeSubjectNodeState?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        ids: Id64Array;
        on: boolean;
    }) => Promise<void>>;
    // (undocumented)
    getCategoryDisplayStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: GetCategoryVisibilityStatusProps) => Promise<VisibilityStatus>>;
    // (undocumented)
    getElementDisplayStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: GetGeometricElementVisibilityStatusProps) => Promise<VisibilityStatus>>;
    // (undocumented)
    getElementGroupingNodeDisplayStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        node: GroupingHierarchyNode;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getModelDisplayStatus?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        id: Id64String;
    }) => Promise<VisibilityStatus>>;
    // (undocumented)
    getSubjectNodeVisibility?: HierarchyVisibilityHandlerOverridableMethod<(props: {
        ids: Id64Array;
    }) => Promise<VisibilityStatus>>;
}

// @public
export function SelectableTree(props: SelectableTreeProps): JSX.Element | null;

// @public
export interface SelectableTreeDefinition {
    getLabel: () => string;
    id: string;
    render: (props: SelectableTreeRenderProps) => React.ReactNode;
    shouldShow?: (imodel: IModelConnection) => Promise<boolean>;
    startIcon?: React.ReactNode;
}

// @public
interface SelectableTreeProps {
    // (undocumented)
    density?: "enlarged" | "default";
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (feature: string, elapsedTime: number) => void;
    // (undocumented)
    trees: SelectableTreeDefinition[];
}

// @public
interface SelectableTreeRenderProps {
    // (undocumented)
    density?: "enlarged" | "default";
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    onPerformanceMeasured?: (featureId: string, elapsedTime: number) => void;
}

// @beta (undocumented)
export function TelemetryContextProvider({ children, onPerformanceMeasured, onFeatureUsed, componentIdentifier, }: PropsWithChildren<TelemetryContextProviderProps>): JSX.Element;

// @beta (undocumented)
interface TelemetryContextProviderProps {
    componentIdentifier: string;
    onFeatureUsed?: (featureId: string) => void;
    onPerformanceMeasured?: (featureId: string, duration: number) => void;
}

// @beta
export function Tree({ getSchemaContext, hierarchyLevelSizeLimit, selectionStorage, imodelAccess: providedIModelAccess, ...props }: TreeProps): JSX.Element;

// @beta (undocumented)
interface TreeCheckboxProps {
    getCheckboxState: (node: PresentationHierarchyNode) => TreeNodeCheckboxState;
    onCheckboxClicked: (node: PresentationHierarchyNode, checked: boolean) => void;
}

// @beta (undocumented)
interface TreeFilteringProps {
    isDisabled?: boolean;
    onFilterClear: () => void;
    onFilterStart: (newFilter: string) => void;
    onSelectedChanged?: (index: number) => void;
    resultCount?: number;
    selectedIndex?: number;
}

// @public (undocumented)
interface TreeHeaderButtonProps {
    // (undocumented)
    density?: "default" | "enlarged";
    // (undocumented)
    onFeatureUsed?: (feature: string) => void;
    // (undocumented)
    viewport: Viewport;
}

// @beta
interface TreeNodeCheckboxState {
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    state: "on" | "off" | "partial";
    // (undocumented)
    tooltip?: string;
}

// @beta (undocumented)
type TreeNodeRendererProps = ComponentPropsWithoutRef<typeof TreeNodeRenderer> & {
    checkboxProps?: TreeCheckboxProps;
};

// @beta (undocumented)
type TreeProps = Pick<FunctionProps<typeof useIModelTree>, "getFilteredPaths" | "getHierarchyDefinition"> & Partial<Pick<FunctionProps<typeof useSelectionHandler>, "selectionMode">> & {
    imodel: IModelConnection;
    getSchemaContext: (imodel: IModelConnection) => SchemaContext;
    treeName: string;
    selectionStorage: SelectionStorage;
    selectionPredicate?: (node: PresentationHierarchyNode) => boolean;
    treeRenderer: (treeProps: Required<Pick<TreeRendererProps, "rootNodes" | "expandNode" | "onNodeClick" | "onNodeKeyDown" | "onFilterClick" | "isNodeSelected" | "getHierarchyLevelDetails" | "size" | "getLabel">>) => ReactNode;
    imodelAccess?: FunctionProps<typeof useIModelTree>["imodelAccess"];
    hierarchyLevelSizeLimit?: number;
    density?: "default" | "enlarged";
    noDataMessage?: ReactNode;
    onReload?: () => void;
    highlight?: HighlightInfo;
};

// @beta
export function TreeRenderer({ rootNodes, expandNode, onNodeClick, onNodeKeyDown, onNodeDoubleClick, isNodeSelected, onFilterClick, getIcon, getLabel, getSublabel, getHierarchyLevelDetails, checkboxProps, reloadTree, size, enableVirtualization, ...props }: TreeRendererProps): JSX.Element;

// @beta (undocumented)
type TreeRendererProps = Pick<TreeNodeRendererProps, "expandNode" | "onNodeClick" | "onNodeKeyDown" | "onFilterClick" | "getIcon" | "getLabel" | "getSublabel" | "getHierarchyLevelDetails" | "checkboxProps" | "reloadTree"> & Omit<ComponentPropsWithoutRef<typeof Tree_2<RenderedTreeNode>>, "data" | "nodeRenderer" | "getNode"> & {
    rootNodes: PresentationTreeNode[];
    isNodeSelected: (nodeId: string) => boolean;
    onNodeDoubleClick?: (node: PresentationHierarchyNode, isSelected: boolean) => void;
};

// @public
export class TreeWidget {
    static get i18n(): Localization;
    static get i18nNamespace(): string;
    static initialize(i18n?: Localization): Promise<void>;
    static terminate(): void;
    static translate(key: string | string[], options?: TranslationOptions): string;
}

// @public
export function TreeWidgetComponent(props: SelectableTreeProps): JSX.Element;

// @public
interface TreeWidgetProps {
    density?: "enlarged" | "default";
    onFeatureUsed?: (feature: string) => void;
    onPerformanceMeasured?: (feature: string, elapsedTime: number) => void;
    trees: SelectableTreeDefinition[];
}

// @beta (undocumented)
export function TreeWithHeader({ filteringProps, buttons, density, children }: PropsWithChildren<TreeWithHeaderProps>): JSX.Element;

// @beta (undocumented)
interface TreeWithHeaderProps {
    // (undocumented)
    buttons?: ReactNode;
    // (undocumented)
    density?: "enlarged" | "default";
    // (undocumented)
    filteringProps?: TreeFilteringProps;
}

// @beta
export function useCategoriesTree({ filter, activeView, onCategoriesFiltered }: UseCategoriesTreeProps): UseCategoriesTreeResult;

// @public
export function useCategoriesTreeButtonProps({ viewport }: {
    viewport: Viewport;
}): {
    buttonProps: Pick<CategoriesTreeHeaderButtonProps, "categories" | "viewport">;
    onCategoriesFiltered: (categories: CategoryInfo[] | undefined) => void;
};

// @beta (undocumented)
interface UseCategoriesTreeProps {
    // (undocumented)
    activeView: Viewport;
    // (undocumented)
    filter: string;
    // (undocumented)
    onCategoriesFiltered?: (categories: CategoryInfo[] | undefined) => void;
}

// @beta (undocumented)
interface UseCategoriesTreeResult {
    // (undocumented)
    categoriesTreeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getFilteredPaths" | "visibilityHandlerFactory" | "highlight" | "noDataMessage">;
    // (undocumented)
    rendererProps: Required<Pick<VisibilityTreeRendererProps, "getIcon" | "getSublabel">>;
}

// @public
export function useFocusedInstancesContext(): FocusedInstancesContext;

// @beta
export function useModelsTree({ activeView, filter, hierarchyConfig, visibilityHandlerOverrides, getFilteredPaths, onModelsFiltered, selectionPredicate: nodeTypeSelectionPredicate, }: UseModelsTreeProps): UseModelsTreeResult;

// @public
export function useModelsTreeButtonProps({ imodel, viewport }: {
    imodel: IModelConnection;
    viewport: Viewport;
}): {
    buttonProps: Pick<ModelsTreeHeaderButtonProps, "models" | "viewport">;
    onModelsFiltered: (models: Id64String[] | undefined) => void;
};

// @beta (undocumented)
interface UseModelsTreeProps {
    // (undocumented)
    activeView: Viewport;
    // (undocumented)
    filter?: string;
    // (undocumented)
    getFilteredPaths?: (props: {
        createInstanceKeyPaths: (props: {
            targetItems: Array<InstanceKey | ElementsGroupInfo>;
        } | {
            label: string;
        }) => Promise<HierarchyFilteringPath[]>;
    }) => Promise<HierarchyFilteringPath[]>;
    // (undocumented)
    hierarchyConfig?: Partial<ModelsTreeHierarchyConfiguration>;
    // (undocumented)
    onModelsFiltered?: (modelIds: Id64String[] | undefined) => void;
    selectionPredicate?: (props: {
        node: PresentationHierarchyNode;
        type: "subject" | "model" | "category" | "element" | "elements-class-group";
    }) => boolean;
    // (undocumented)
    visibilityHandlerOverrides?: ModelsTreeVisibilityHandlerOverrides;
}

// @beta (undocumented)
interface UseModelsTreeResult {
    // (undocumented)
    modelsTreeProps: Pick<VisibilityTreeProps, "treeName" | "getHierarchyDefinition" | "getFilteredPaths" | "visibilityHandlerFactory" | "highlight" | "noDataMessage" | "selectionPredicate">;
    // (undocumented)
    rendererProps: Required<Pick<VisibilityTreeRendererProps, "getIcon" | "onNodeDoubleClick">>;
}

// @beta
export interface VisibilityStatus {
    isDisabled?: boolean;
    state: "visible" | "partial" | "hidden";
    tooltip?: string;
}

// @beta
export function VisibilityTree({ visibilityHandlerFactory, treeRenderer, ...props }: VisibilityTreeProps): JSX.Element;

// @beta (undocumented)
type VisibilityTreeProps = Omit<TreeProps, "treeRenderer" | "imodelAccess"> & {
    visibilityHandlerFactory: (props: {
        imodelAccess: ECClassHierarchyInspector;
    }) => HierarchyVisibilityHandler;
    treeRenderer: (treeProps: FunctionProps<TreeProps["treeRenderer"]> & Pick<VisibilityTreeRendererProps, "getCheckboxState" | "onCheckboxClicked">) => ReactNode;
};

// @beta
export function VisibilityTreeRenderer({ getCheckboxState, onCheckboxClicked: onClick, ...props }: VisibilityTreeRendererProps): JSX.Element;

// @beta (undocumented)
type VisibilityTreeRendererProps = TreeRendererProps & TreeCheckboxProps;

// (No @packageDocumentation comment for this package)

```
