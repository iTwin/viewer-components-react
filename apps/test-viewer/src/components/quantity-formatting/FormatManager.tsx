/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/

import { BeEvent } from "@itwin/core-bentley";
import { IModelApp } from "@itwin/core-frontend";
import { SchemaFormatsProvider, SchemaItem, SchemaItemType, SchemaKey, SchemaMatchType } from "@itwin/ecschema-metadata";

import type { IModelConnection } from "@itwin/core-frontend";
import type { FormatDefinition, FormatsChangedArgs, FormatsProvider, MutableFormatsProvider } from "@itwin/core-quantity";
import type { FormatSet } from "@itwin/ecschema-metadata";
export class FormatManager {
  protected static _instance: FormatManager;
  private _formatSets: FormatSet[] = [];
  private _fallbackFormatProvider?: FormatsProvider;
  private _activeFormatSet?: FormatSet;
  private _activeFormatSetFormatsProvider?: FormatSetFormatsProvider;
  private _iModelOpened: boolean = false;
  private _removeListeners: (() => void)[] = [];

  /** Event raised when the active format set changes */
  public readonly onActiveFormatSetChanged = new BeEvent<(formatSet: FormatSet | undefined) => void>();

  public static get instance(): FormatManager | undefined {
    return this._instance;
  }

  public get formatSets(): FormatSet[] {
    return this._formatSets;
  }

  public set formatSets(formatSets: FormatSet[]) {
    this._formatSets = formatSets;
  }

  public get activeFormatSet(): FormatSet | undefined {
    return this._activeFormatSet;
  }

  public get activeFormatSetFormatsProvider(): FormatSetFormatsProvider | undefined {
    return this._activeFormatSetFormatsProvider;
  }

  /** Initialize with a set of format sets to use */
  public static async initialize(formatSets: FormatSet[], fallbackProvider?: FormatsProvider): Promise<void> {
    if (this._instance) throw new Error("FormatManager is already initialized.");

    this._instance = new FormatManager(formatSets, fallbackProvider);
  }

  public constructor(formatSets: FormatSet[], fallbackProvider?: FormatsProvider) {
    this._formatSets = formatSets;
    this._fallbackFormatProvider = fallbackProvider;
  }

  public [Symbol.dispose](): void {
    for (const listener of this._removeListeners) {
      listener();
    }
    this._removeListeners = [];
  }

  public setActiveFormatSet(formatSet: FormatSet): void {
    const formatSetFormatsProvider = new FormatSetFormatsProvider(formatSet, this._fallbackFormatProvider);
    this._activeFormatSet = formatSet;
    this._activeFormatSetFormatsProvider = formatSetFormatsProvider;

    if (this._iModelOpened) {
      IModelApp.formatsProvider = formatSetFormatsProvider;
    }

    this.onActiveFormatSetChanged.raiseEvent(formatSet);
  }

  // Typically, enables a SchemaFormatsProvider to be the fallback during runtime.
  public set fallbackFormatsProvider(provider: FormatsProvider | undefined) {
    this._fallbackFormatProvider = provider;
    if (this._activeFormatSet) {
      // If we have an active format set, we need to update the formats provider to include the new fallback.
      const newFormatSetFormatsProvider = new FormatSetFormatsProvider(this._activeFormatSet, this._fallbackFormatProvider);
      this._activeFormatSetFormatsProvider = newFormatSetFormatsProvider;
      IModelApp.formatsProvider = newFormatSetFormatsProvider;
    }
  }

  public get fallbackFormatsProvider(): FormatsProvider | undefined {
    return this._fallbackFormatProvider;
  }

  public async onIModelClose() {
    // Clean up listeners
    this._removeListeners.forEach((removeListener) => removeListener());
    this._fallbackFormatProvider = undefined;
    if (this._activeFormatSetFormatsProvider) {
      this._activeFormatSetFormatsProvider.clearFallbackProvider(); // Works here because the fallback provider is the SchemaFormatsProvider used onIModelOpen.
    }
    this._iModelOpened = false;
  }

  /**
   * If FormatSetFormatsProvider was successfully set, renders the usage of IModelApp.quantityFormatter.activeUnitSystem pointless when formatting.
   */
  public async onIModelOpen(iModel: IModelConnection): Promise<void> {
    // Set up schema-based units and formats providers
    const schemaFormatsProvider = new SchemaFormatsProvider(iModel.schemaContext, IModelApp.quantityFormatter.activeUnitSystem);
    this.fallbackFormatsProvider = schemaFormatsProvider;
    this._removeListeners.push(
      this.onActiveFormatSetChanged.addListener((formatSet) => {
        if (formatSet && formatSet.unitSystem !== schemaFormatsProvider.unitSystem) {
          schemaFormatsProvider.unitSystem = formatSet.unitSystem;
        }
      }),
    );
    // Query schemas for KindOfQuantity items
    try {
      const schemaFormatSet: FormatSet = {
        name: "AutogeneratedFormatSet",
        label: "Auto-generated Format Set from iModel",
        unitSystem: IModelApp.quantityFormatter.activeUnitSystem,
        description:
          "This format set was automatically created based on the data in the opened iModel. It provides formatting for all quantities used in the model.",
        formats: {},
      };
      // Used until https://github.com/iTwin/bis-schemas/issues/566 is resolved
      // If there are duplicate labels, use the unique fullName of the KoQ instead of it's label.
      const usedLabels: Set<string> = new Set();

      // Try to get known schemas that typically contain KindOfQuantity items, and get all the formats from kind of quantities
      const schemaNames = ["AecUnits"];

      for (const schemaName of schemaNames) {
        try {
          const schema = await iModel.schemaContext.getSchema(new SchemaKey(schemaName, SchemaMatchType.Latest));
          if (schema) {
            for (const schemaItem of schema.getItems()) {
              if (schemaItem.schemaItemType === SchemaItemType.KindOfQuantity) {
                const format = await schemaFormatsProvider.getFormat(schemaItem.fullName);
                if (format) {
                  if (format.label) {
                    if (usedLabels.has(format.label)) {
                      (format as any).label = `${format.label} (${schemaItem.key.schemaName})`;
                    }
                    usedLabels.add(format.label);
                  }
                  schemaFormatSet.formats[schemaItem.fullName] = format;
                }
              }
            }
          }
        } catch (error) {
          console.warn(`Schema ${schemaName} not found or failed to load:`, error);
        }
      }

      // Get all used KindOfQuantities from the iModel, and populate the formatSet.
      const ecsqlQuery = `
        SELECT
          ks.Name || '.' || k.Name AS kindOfQuantityFullName,
          COUNT(*) AS propertyCount,
          json_group_array(p.Name) AS propertyNames
        FROM
          ECDbMeta.ECPropertyDef p
          JOIN ECDbMeta.KindOfQuantityDef k ON k.ECInstanceId = p.KindOfQuantity.Id
          JOIN ECDbMeta.ECSchemaDef ks ON ks.ECInstanceId = k.Schema.Id
        GROUP BY
          ks.Name,
          k.Name
        ORDER BY
          propertyCount DESC;
      `;
      const reader = iModel.createQueryReader(ecsqlQuery);
      const allRows = await reader.toArray();
      for (const row of allRows) {
        const formatName = row[0];
        const format = await schemaFormatsProvider.getFormat(formatName);
        if (format) {
          if (format.label) {
            if (usedLabels.has(format.label)) {
              const schemaName = formatName.split(".")[0];
              (format as any).label = `${format.label} (${schemaName})`;
            }
            usedLabels.add(format.label);
          }
          schemaFormatSet.formats[formatName] = format;
        }
      }

      // Set this as the active format set if we found any formats
      if (Object.keys(schemaFormatSet.formats).length > 0) {
        this._iModelOpened = true;
        this._formatSets.push(schemaFormatSet);
        this.setActiveFormatSet(schemaFormatSet);

        console.log(`Created schema-based format set with ${Object.keys(schemaFormatSet.formats).length} formats`);
      } else {
        console.log("No KindOfQuantity items found in known schemas");
      }
    } catch (error) {
      console.error("Failed to query schema items:", error);
    }
  }
}

export class FormatSetFormatsProvider implements MutableFormatsProvider {
  public onFormatsChanged: BeEvent<(args: FormatsChangedArgs) => void> = new BeEvent<(args: FormatsChangedArgs) => void>();

  private _formatSet: FormatSet;
  private _fallbackProvider?: FormatsProvider;

  public constructor(formatSet: FormatSet, fallbackProvider?: FormatsProvider) {
    this._formatSet = formatSet;
    this._fallbackProvider = fallbackProvider;
  }

  public async addFormat(name: string, format: FormatDefinition): Promise<void> {
    this._formatSet.formats[name] = format;
    this.onFormatsChanged.raiseEvent({ formatsChanged: [name] });
  }

  public clearFallbackProvider(): void {
    this._fallbackProvider = undefined;
  }

  public async getFormat(input: string): Promise<FormatDefinition | undefined> {
    // Normalizes any schemaItem names coming from node addon 'schemaName:schemaItemName' -> 'schemaName.schemaItemName'
    const [schemaName, itemName] = SchemaItem.parseFullName(input);

    const name = schemaName === "" ? itemName : `${schemaName}.${itemName}`;
    const format = this._formatSet.formats[name];
    if (format) return format;
    if (this._fallbackProvider) return this._fallbackProvider.getFormat(name);
    return undefined;
  }

  public async removeFormat(name: string): Promise<void> {
    delete this._formatSet.formats[name];
    this.onFormatsChanged.raiseEvent({ formatsChanged: [name] });
  }
}
